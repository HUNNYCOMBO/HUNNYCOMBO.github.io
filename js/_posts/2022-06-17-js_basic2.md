---
title: 코딩엘리 자바스크립트 입문편 2 - 비동기 프로그래밍
excerpt: 비동기 프로그램이에 대하여 공부합니다.
tags: [js, async, callback, promise]
---

## 1. 동기와 비동기
js는 동기적인 언어입니다. hoisting(var, function 선언이 최상단으로 올라가는 것)이 된 이후 부터 코드가 나타나는 순서대로 실행이 됩니다. callback 함수에 대해 다시 알아봅니다.  
callback함수는 우리가 전달해준 함수를 원할때 다시 실행시켜 달라는 의미입니다. browserAPI인 setTimeout의 정의를 살펴보면 handeler라는 callback함수를 파라미터로 받는 것을 볼 수 있습니다.  

```javascirpt
console.log('1');
setTimeout(function () {
  console.log('2');
  }, 1000);
console.log('3');
```

![image](https://user-images.githubusercontent.com/78904413/174243064-752bfb8b-e66c-48d4-9131-a48cf30dbf94.png)
절차대로 1을 찍고 2에서는 browserAPI를 만났으므로 browser에서 1초의 시간이 지난 후 2를 출력하라는 신호를 보내게 되어 콘솔이 아래와 같이 찍히게 됩니다. 이것이 async 입니다.  


![image](https://user-images.githubusercontent.com/78904413/174548581-493ebf05-4dbe-40b2-a2be-c7a5099fa08e.png)

### 1.1. 콜백 정리
콜백은 비동기적 상황에서만 사용하는 것은 아닙니다. 비동기와 동기 콜백으로 나뉘어 집니다. 위의 자바스크립트와 합쳐서 생각해봅니다.  
```javascript
// 동기적인 콜백
function printImmeditaely(print) {  // 함수는 hositng됩니다.
  print();
}
printImmediately(()=>console.log('hello'));
```

![image](https://user-images.githubusercontent.com/78904413/174549193-6a29b405-2891-43bf-83f6-40093c3331e3.png)

이제 비동기적 콜백을 알아봅니다.  
```javascript
function printWithDelay(print, timeout){
  setTimeout(print, timeout);
}
printWithDelay(()=>console.log('async callback'), 2000);
```

![image](https://user-images.githubusercontent.com/78904413/174549446-6fdced98-a91c-44c7-bc8a-558d78ae1e97.png)

### 1.2.  콜백 지옥(콜백 )
콜백은 유용하지만 너무 남발하게되면 콜백지옥에 빠지기 쉽습니다. 콜백지옥을 체험하는 코드를 작성해봅니다.  

```javascript
// 콜백지옥 로그인 성공시 성공했다는 onSuccess 콜백함수, 에러시 onError 콜백 함수, 로그인 성공시 역할을 불러오는 함수실행
class UserStorage {
  loginUser(id, password, onSuccess, onError) {
    setTimeout(()=>{
      if(로그인 로직 생략){
        onSuccess(id)
      }else{
        onError(new Error('not found')); 
      }      
    }, 2000);
  }
  
  getRoles(user, onSuccess, onError) {
    setTimeout(()=>{
      if(user === 'lala') {
        onSuccess({ name: 'lala', role: 'admin'});
      }else{
        onError(new Error('no access'));
      }
    },1000);
  }
}

const userStorage = new UserStorage();
const id = prompt('enter your id');
const password = prompt('enter your password');
userStorage.loginUser(
  id,
  password,
  user => {
    userStorage.getRoles(
      user,
      userWithRole => {
        alert(`Hello ${userWithRole.name}, you have a ${userWithRole.role} role`);
    },
    error => {
      console.log(error);
     }
    );
  },
  error => {
    console.log(error);
  }
);
```

![image](https://user-images.githubusercontent.com/78904413/174552302-575a388b-49f5-455d-a50f-6411eb327ae4.png)

이처럼 콜백안에 콜백을 계속 전달하는 것을 콜백 체인이라하며 이는 가독성이 매우 떨어집니다.

## 2. promise
promise는 callback을 사용하지 않고 비동기코드를 처리할 수 있는 API입니다. promise는 js안에 내장된 object입니다.  

### 2.1. state
promise의 상태에는 pending(진행중), fulfilled(성공), rejected(실패) 상태가 있습니다.

### 2.2. producer
```javascript
const promise = new Promise(resolve, reject) => { // 결과가 성공일 때 호출하는 resolve, 오류일때 실행되는 reject
  // doing executor something(network, read files...)
  resolve('lala');
  reject(new Error('no network'));
})
```
 promise object 생성시 executor함수가 바로 실행됩니다. executor 안에는 상태에 따라 호출되는 resolve와 reject함수가 들어갑니다. 만약 버튼을 눌렀을 때 비동기동작을 해야한다면, promise가 생성되는 동시에 executor가 실행되는 점에 주의해야 합니다.  
 
### 2.3. consumers
then, catch, finally를 통해 값을 받아 올 수 있습니다.  
```javascript
promise
  .then((vlaue) => { // 올바르게 promise를 수행하면 value로 resolve 콜백함수에 전달한 값이 파라미터로 들어옵니다.
    console.log(value);
  })
  .catch(error => { // reject의 error 를 전달 받아 처리합니다.
    console.log(error); 
  })
  .finally(()=>{console.log('finaylly')});  // 무조건 한번 실행됩니다.
```
![image](https://user-images.githubusercontent.com/78904413/174714758-f839e2ca-69ff-47e3-817b-f76c5aa4fff2.png)

### 2.4. promise chaining
```javascript
const fetchNumber = new Promise((resolve, rejected) => {
  setTimeout(() => resolve(1), 1000);
});

fetchNumber
  .then(num => num *2)
  .then(num => num *3)
  .then(num => {
    return new Promise((resolve, reject) => {   // 새로운 promise 전달
      setTimeout(() => resolve(num -1), 1000);
    });
  })
  .then(num => console.log(num));
```
![image](https://user-images.githubusercontent.com/78904413/174715507-a916350f-c72e-496c-95c9-b60b654a8382.png)

### 2.5. call back 지옥 함수 리팩토링
1.2. 에서 보았던 콜백 지옥 함수를 promise chainnig으로 변경해 봅니다.  
```javascript
class UserStorage {
  loginUser(id, password) {
    return new Promise((resolve, reject) => {
      setTimeout(()=>{
        if(로그인 로직 생략){
          resolve(id);
        }else{
          reject(new Error('not found'));
        }      
      }, 2000);
    });
  }
  
  getRoles(user) {
    return new Promise((resolve, reject) => {
      setTimeout(()=>{
        if(user === 'lala') {
          resolve({ name: 'lala', role: 'admin'});
        }else{
          reject(new Error('no access'));
        }
      },1000);
    });
  }
}

const userStorage = new UserStorage();
const id = prompt('enter your id');
const password = prompt('enter your password');
userStorage.loginUser(id, password)
  .then(user => userStorage.getRoles) // 인자가 같다면 생략가능
  .then(alert(`Hello ${user.name}, you have a ${user.role} role!`)) // user => 를 생략
  .catch(console.log);
```

---
title: "드림코딩(youtube) - 자바스크립트 기초강의"
excerpt: "자바스크립트 기초 강의 유튜브 드림코딩님의 강의를 기록합니다."
tags: [js]
header:
  teaser: 
---

## 1. JavaScript 넌 누구니?
동적인 웹사이트를 만들기 위해서 Marc Andreessen이 고안한 DOM요소들을 조작하는 scripting 언어 입니다.  
이후 Javascript를 그대로 복사한 Jscript 등 다양한 언어들이 등장하며 정규화 되지 못하고 각 브라우저에서만 호환되는 불편한 상황이 지속 됐습니다.  
AJAX(Asynchronous JavaScript and XML, 비동기적으로 서버에서 데이터를 가져오고 처리하는 기술)가 등장하고, 각종 라이브러리(jQuery, dojo, mootools ...)가 제공하는 APIs를 이용하여 더이상 브라우저에 의존하지 않는 개발이 가능해졌습니다.  

![image](https://user-images.githubusercontent.com/78904413/173223658-7a34ca2c-d5d0-44b4-88c8-752968324bc2.png)  

여기서 배울 수 있는 좋은 프로그래밍 철학은, 각 layer에 종속되지 않는 interface를 만들어서 구현사항이 변경되어도 사용자의 코드는 변화하지 않도록 하는 것이 좋은 코드입니다.  

이후 ECMAscript(표준사항)도 더욱 발전하여 5,6에서 많은 기능들이 추가되어 라이브러리의 도움 없이 모든 웹브라우저에서 호환이 됩니다.  

![image](https://user-images.githubusercontent.com/78904413/173223846-cbeac6c4-9ec9-46f0-9a4a-8597c8869ea0.png)
각 브라우저에서 사용되는 Javascript 엔진은 모두 다릅니다. 그중에 V8엔진은 node.js나 ELECTRON에서도 많이 사용됩니다.  

### 1.1. BABEL
개발자는 최신버전으로 개발을 하고싶고 사용자는 항상 최신 브라우저를 사용하는 것은 아니기 때문에, 최신 ECMAscript로 개발을 하고 사용자에게 배포할 때만 ECMAscript 5,6로 변환해주는 transcompiler를 BABEL이라고 합니다.  

![image](https://user-images.githubusercontent.com/78904413/173223941-6e3e78ed-3ede-4e66-a5df-3a5dea1e8e1b.png)

### 1.2. SPA
최근에는 Single Page Application 이라는 하나의 페이지에서 필요한 부분만 업데이트 하는 것이 개발 경향입니다. 이런 개발동향을 위해서 제공되는 것이 React, viewjs 같은 프레임워크 입니다.  
![image](https://user-images.githubusercontent.com/78904413/173224037-3b3287e7-a692-4c20-91db-57c6783f2906.png)

### 1.3. nodejs
강력한 V8엔진과 ECMAscript를 통해서 nodejs가 등장하게 됩니다. nodejs는 javascript 엔진을 이용하여 ServerSide 개발이 가능하게 하는 프레임워크입니다.
그외 다양한 프레임워크를 통해 모바일 웹페이지나 데스크탑 앱을 만드는 등 잠재력이 무궁무진합니다.    

### 1.4. 뜨고있는 기술
브라우저에서 동작할 수 있는 유일한 언어는 javacript였지만, WebAssembly의 등장으로 C++, java 등 다양한 언어를 이용하여 웹브라우저에서 동작할 수 있는 기술이 주목받고 있습니다.  

### 1.5. 콘솔에 출력
이제 본격적으로 콘솔에 Hello World를 출력해보고 js 강의를 시작합니다.  
```javascript
console.log('Hello World');
```
만약 nodejs가 설치되어 있다면 해당 폴더에서 node 파일명만 입력하면 Hello World의 출력을 확인할 수 있습니다.  

![image](https://user-images.githubusercontent.com/78904413/173224562-27136598-058e-4089-925a-762290349545.png)

vscode를 이용하여 index.html파일을 생성하고 script태그를 이용하여 main.js를 추가합니다.  

```html
...
<head>
  ...
  <script src="main.js"></script>
...
```
vscode의 open with live server를 이용하면 브라우저에서 바로 확인가능합니다.  
- 윈도우 단축키 : Ctrl Shift i
- 맥 단축키 : cmd option i

![image](https://user-images.githubusercontent.com/78904413/173224911-44c3c08b-cc41-44ba-808a-fbe78fe5557e.png)

이 console API의 log라는 함수를 이용해서 우리가 원하는 메세지를 콘솔창에 출력했습니다.  
또한 nodejs를 이용한 콘솔창 출력도 확인할 수 있었습니다. 이는 nodejs와 webAPI(브라우저가 제공하는 함수) 둘 다 console에 관련된 API를 갖고 있는 것입니다. mdn라이브러리에서 해당 내용을 확인할 수 있습니다.  

### 1.6. dev tools(개발자 도구)
브라우저의 개발자도구를 이용하면 개발에 많은 도움을 받을 수 있습니다.  
- Elements 탭은 html에서 작성한 요소들을 확인할 수 있습니다.
- Console 탭에서는 단순 로그 뿐만 아니라 js를 실행할 수 있어서 다양하게 활용 할 수 있습니다.
- Sources 탭에서는 디버깅에 유용한 탭입니다.

### 1.7. js 공식 사이트
[js의 공식 문서](ecma-international.org)를 통해 공식문서를 확인할 수 있습니다.  
[mozilla-mdn](developer.mozilla.org)사이트에서는 js 공식문서로 공부하기 좋습니다.  

## 2. async VS defer
html에서 js를 어떻게 추가하는 것이 더 효율적인지에 대한 문제입니다.

### 2.1. head에 추가하는 경우
![image](https://user-images.githubusercontent.com/78904413/173225483-a57650a7-74a6-428a-a8f8-ab677e6d6072.png)

앞선 경우처럼 head에 script를 추가하는 경우, 브라우저가 한줄씩 파싱해 DOM요소로 변환시킵니다.  
이후 script태그가 보이면 pasing을 멈추고 script를 fetching하고 실행 한 후 다시 parsing 합니다.  

이런 방식은 js파일이 어마어마하게 큰 경우, 사용자가 페이지를 읽어오는데 많은 시간이 소요됩니다.  
### 2.2. body 끝부분에 추가하는 경우
![image](https://user-images.githubusercontent.com/78904413/173225566-2c5c422b-b14e-4d5f-b3ca-bed686a7f5b2.png)

이때는 페이지를 모두 불러온 다음 fetching하기 때문에 js를 받기전에도 사용자가 컨텐츠를 빨리 볼 수 있습니다. 하지만 js에 의존적인 페이지라면 정상적인 페이지를 볼 수 없습니다.  

### 2.3. head + async
![image](https://user-images.githubusercontent.com/78904413/173225702-6750e1cc-1ec9-4fc2-8ba6-0bc7cf327803.png)

head안에 script를 이용하는 것에 asyn속성을 추가하는 것입니다. 1번의 경우와 마찬가지로 parshing하다 asyn를 만나게 되면 병렬로 fetching을 진행하고 완료하면 pasing을 멈추고 executing을 하게 됩니다.  
병렬 처리로 다운로드 시간을 줄일 수 있지만, js에서 queryselector를 이용하여 DOM요소를 조작하는 등의 행위를 할 때, html이 parsing되기 전에 executing 되기에 문제를 야기할 수 있습니다.


### 2.4. head + defer(권장)
![image](https://user-images.githubusercontent.com/78904413/173225766-4774d8f0-8f1a-490b-be38-7ec38ec7b784.png)

async의 경우처럼 병렬처리를 하지만 parsing을 끝낸 다음 excuting 합니다.

### 2.5. async와 defer의 차이
![image](https://user-images.githubusercontent.com/78904413/173225839-cae88627-dd4d-40a6-bfd9-8036b1921532.png)

async의 경우 스크립트에 정의된 순서에 상관 없이 먼저 fetching된 스크립트를 execuitng합니다. 순서가 중요한 script일 경우 문제가 될 수 있습니다.  

![image](https://user-images.githubusercontent.com/78904413/173225869-4de22cbc-87a7-45b4-8d8e-11ad86bed52a.png)

defer의 경우 순서가 지켜집니다.

### 2.6. use strict
```javascript
'use strict';
```
순수언어인 바닐라자바스크립트를 사용할 때는 use strict를 선언해주는 것이 좋습니다.  
js는 유연한 만큼 위험합니다. 예를들면 선언되지 않은 변수의 값을 할당하거나 기존에 선언된 프로토타입을 변경하는 등 비상식적인 행위가 가능합니다.  
ECMAScirpt5에 추가된 use strict를 선언하면 이런 위험한 행위를 방지할 수 있습니다.  
![image](https://user-images.githubusercontent.com/78904413/173226027-65069de5-3dc9-4ce8-8cfb-ce97edee33a9.png)

## 3. 데이터 타입
### 3.1. Variable(변수)
js에서 변수를 선언할 때는 **let**으로 선언합니다. 이는 ES6에서 추가되었습니다.  
```javascript
let name = 'lala';
console.log(name);
name = 'ogu';
console.log(name);
```
![image](https://user-images.githubusercontent.com/78904413/173226238-1034afee-5c13-43e7-85a6-f83b5db2bce2.png)
name 이라는 변수의 값이 변하여 출력되는 것을 확인할 수 있습니다.  
변수를 선언하면 애플리케이션 마다 부여된 메모리에서 name이라는 변수를 저장하는 포인터가 생기게 됩니다.  
![image](https://user-images.githubusercontent.com/78904413/173226318-4b1562bf-4731-4969-a450-75c703dfef76.png)

![image](https://user-images.githubusercontent.com/78904413/173226304-3ae8c88c-d1cb-4988-a6e4-7e297228dac6.png)

### 3.2. Block scope
블록을 이용하면 일종의 지역변수처럼 사용되 해당 블록 밖에서는 변수를 사용할 수 없게됩니다.  
블록 없이 선언한 변수는 global 변수로 전역에서 사용될 수 있습니다.  
![image](https://user-images.githubusercontent.com/78904413/173226410-7a9bc307-589c-4679-8007-030e0fbf84b1.png)
전역 변수는 애플리케이션이 종료될 때 까지 메모리에 남아있기 때문에 가능하면 최소한으로 클래스나 함수 등 필요한 부분에서만 선언하는 것이 좋습니다.

### 3.3. var(사용 금지)
ES6전에 사용하던 변수 선언으로 var를 이용하면 변수를 선언하기 전에 값을 할당 할 수 있었으므로 많은 문제를 야기합니다.  
이것을 var hoisting 이라고 합니다. 정확히는 어디에 선언하든 상관없이 항상 제일 위로 선언을 끌어 올려주는 것입니다.  
```javascript
console.log(age);
age = 5;
var age;
```
의 경우 var age; 가 제일 위로 선언되어 정의되지 않은 값이 콘솔에 출력됩니다. 또한 var는 Block scope를 무시합니다.  

물론 let을 사용하려면 웹브라우저가 es6를 지원해야합니다. 메이저 브라우저중에는 익스플로러를 제외하고 지원하기 때문에 let을 사용해도 됩니다.  

### 3.4. Constants(read only)
const는 java의 final 키워드와 같다고 볼 수 있습니다. 한번 값이 할당되면 변하지 않는 Immutable타입입니다.  
이런 상수 타입은 보안이 강하고 thread safety하며 실수를 방지 할 수 있습니다.  
![image](https://user-images.githubusercontent.com/78904413/173226974-243628b6-62da-4274-8ca6-95f32c0a00ae.png)

### 3.5. Variable types
모든 언어는 원시 타입과 객체(참조)타입으로 나뉩니다.  

#### 3.5.1. primitive type
더 이상 작은 단위로 나누어질 수 없는 한가지 아이템 입니다. number, string, boolean, null, undefined, symbol이 있습니다. 메모리에 값 자체가 저장됩니다. Immutable data타입 입니다.  

#### 3.5.2. object type(참조 타입)
아이템들을 묶어서 한 단위로 관리해주는 타입입니다. box, container 등이 있습니다.  
값이 저장되는 것이 아닌 object가 담겨있는 메모리의 주소값을 참조합니다. mutable타입입니다.

```javascript
const lala = { name: 'lala', age:30 };
// const로 선언된 lala포인터는 변경이 불가능하지만, lala object안의 name과 age값은 변경 가능합니다.
lala.age = 31;
```
![image](https://user-images.githubusercontent.com/78904413/173228061-943cc988-0d40-4d52-b7e1-2f1d2b55e8c9.png)




#### 3.5.3. function
function도 데이터타입 중 하나로 first-class function(일급함수)를 지원한다는 의미는 다른 데이터타입처럼 변수로 선언이되고 매개변수 인자 등으로 사용할 수 있으며 function으로 return할 수 도 있다는 의미입니다.  

### 3.6. C언어와의 비교
![image](https://user-images.githubusercontent.com/78904413/173227172-180a3dfb-696d-4287-a4df-8e2f89fc2b18.png)
C언어나 java에서는 좀더 세세한 숫자 타입을 선언할 수 있습니다. 이런 low level 프로그래밍으로 얻는 이점은 개발자가 세세하게 메모리 최적화를 할 수 있는 것입니다.  
반면 js는 number라는 키워드가 있음에도 let으로 통일하여 선언할 수 있습니다.  

### 3.7. 특별한 숫자 키워드(에러방지)
![image](https://user-images.githubusercontent.com/78904413/173227274-481013cc-c7b7-4ddc-8962-d2c5b091932d.png)

- Infinity : 무한대
- -Infinity : -무한대
- NaN : 숫자가 아님

### 3.8. string
js의 string은 글자 수에 제약 받지 않습니다.
```javascript
const brendan = 'brendan';
const greeting = 'hello' + brendan; // ''와 변수의 차이에 주목
console.log(`value: ${greeting}, type: ${typeof greeting}`);
const helloBob = `hi ${brendan}!`;
// template literal ''가 아닌 ``을 이용하면 + 없이 붙어 나옵니다.
// 기존의 방식 : console.log('value: ' + helloBob + ' type: ' + typeof helloBob);
console.log(`value: ${helloBob}, type: ${typeof helloBob}`);
```
![image](https://user-images.githubusercontent.com/78904413/173227483-eb6b58ed-eead-4308-bb3e-43903e9f0f2b.png)

### 3.9. boolean
false에 할당 되는 값은 0, null, undefined, NaN, ''을 포함합니다.  

### 3.10. undefined
null과 다르게 변수를 선언하고 어떠한 값도 정의하지 않는 값입니다.  

### 3.11. symbol
고유한 식별자가 필요할 때 사용합니다. 동일한 string으로 식별자를 부여했어도 다른 symbol로 구별됩니다.  
동일한 식별자로 구분하고싶다면 Symbol.for메소드를 이용합니다. 출력 할때는 description 메소드를 이용하여 출력합니다.  

## 4. Dynamic typing
js는 선언할 때 어떤 타입인지 선언하지 않고, 런타임 시에 할당된 값에 따라 타입이 변경 될 수 있음을 의미합니다.  
빠르게 개발할 때는 유용하지만 규모가 있는 애플리케이션을 제작 할 때에는 위험 할 수 있습니다.  
이를 위하여 typescript가 등장했습니다.  

## 5. operator
![image](https://user-images.githubusercontent.com/78904413/173228288-2215cecd-01b9-447f-a4b6-efe0a6ae6628.png)
간단히 console로 출력하는 방법만 살펴봅니다. 이때 팁은 check()함수는 그 행위가 가장 크므로 순서상 가장 뒤에 놓습니다.  

== 연산자의 경우, 타입에 상관없이 값만 비교합니다. 타입을 비교하는 ===연산을 권장합니다.  
![image](https://user-images.githubusercontent.com/78904413/173228437-36a7aed9-ce2c-4165-86c3-2cf3af853ef0.png)

참조 타입의 경우 참조하는 곳이 같을 경우만 true입니다.  
![image](https://user-images.githubusercontent.com/78904413/173228518-9506374f-4ea9-4580-97ad-d4357f7206fd.png)

![image](https://user-images.githubusercontent.com/78904413/173228541-71a0ad16-7ef1-4cdc-8a09-3a18ef060016.png)








